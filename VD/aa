#include "CdCmd.h"
#include "VirtualDiskInside.h"



bool CdCmd::Execute(VirtualDiskInside * virtualdiskInside)
{
	//从命令参数中取出路径
	vector<string> pathItem = cmdParaCollection.m_pathItems;

	//该命令最多支持一条路径
	if (pathItem.size() > 1)
	{
		return false;
	}
	//该命令支持空路径，如果路径为空，则显示当前路径
	if (pathItem.empty())
	{
		//打印当前路径****************************
		virtualdiskInside->LogMsgToConsole(virtualdiskInside->GetWorkingPath().str());
		return false;
		//不处理
	}
	else
	{
		Path path(pathItem[0]);
		//根据路径去寻找相应的节点
		CellNode* node = virtualdiskInside->GetNodeByPath(path);
		node = virtualdiskInside->LookingForTaget(node);
		if (!node)
		{
			virtualdiskInside->LogMsgToConsole("路径不存在或为文件名");
			return false;
		}
		else if (node->GetNodeType()& FOLD)
		{
			virtualdiskInside->SetWorkingNode(node);
			return true;
		}
		else
		{
			//路径不存在或为文件名
			virtualdiskInside->LogMsgToConsole("路径不存在或为文件名");
			return false;
		}
	}
}

#pragma region 丢弃方法
//
//bool CdCmd::Execute(VirtualDisk * virtualdisk)
//{
//	//从命令参数中取出路径
//	vector<string> pathItem = cmdParaCollection.m_pathItems;
//
//	//该命令最多支持一条路径
//	if (pathItem.size() > 1)
//	{
//		return false;
//	}
//	//该命令支持空路径，如果路径为空，则显示当前路径
//	if (pathItem.empty())
//	{
//		//打印当前路径****************************
//		virtualdisk->LogMsgToConsole(virtualdisk->GetWorkingPath().str());
//		return false;
//		//不处理
//	}
//	else
//	{
//		Path path(pathItem[0]);
//		//根据路径去寻找相应的节点
//		//CellNode* node = virtualdisk->GetNodeByPath(path);
//		vector<string> items = path.split();
//		CellNode* curNode = virtualdisk->GetNodeByPath(path.StartNode());
//		for (size_t i = 0; i < items.size(); i++)
//		{
//			if (curNode == NULL)
//			{
//
//				return false;
//			}
//
//			//根据当前节点名称去寻找相应的节点
//			CellNode* child = curNode->GetNode(items[i]);
//
//			if (!child)
//			{
//				virtualdisk->LogMsgToConsole("路径不存在或为文件名");
//				return false;
//			}
//
//			if (child->GetNodeType() == FOLD || child->GetNodeType() == LINK || child->GetNodeType() == DISK)
//			{
//				//如果child的类型为文件夹，则curNode = child ; 若类型为link，则curNode 等于 child的target
//				curNode = virtualdisk->LookingForTaget(child);
//				if (curNode->GetNodeType() == FILE_CUSTOM)
//				{
//					virtualdisk->LogMsgToConsole("路径不存在或为文件名");
//					return false;
//				}
//				continue;
//			}
//			else
//			{
//				//路径不存在或为文件名
//				virtualdisk->LogMsgToConsole("路径不存在或为文件名");
//				return false;
//			}
//		}
//
//		if (curNode == NULL)
//		{
//			virtualdisk->LogMsgToConsole("找不到路径或者文件");
//			return false;
//		}
//		else if (curNode->GetNodeType() == FOLD || curNode->GetNodeType() == DISK)
//		{
//			virtualdisk->SetWorkingNode(curNode);
//			return true;
//		}
//		else
//		{
//			virtualdisk->LogMsgToConsole("路径只支持文件夹名");
//			return false;
//		}
//	}
//
//}

#pragma endregion#include "CellNode.h"

CellNode::CellNode()
{
	nodeType = FOLD;
	preLink = NULL;
	UpdateLastModifyTime();
}

//在当前节点删除时，删除其链表中的每个节点
CellNode::~CellNode()
{
	list<CellNode*>::iterator itera = subCellNodeList.begin();
	for (itera; itera != subCellNodeList.end(); itera++)
	{
		delete *itera;
	}
	subCellNodeList.clear();
}

//向当前节点的子节点链表中插入元素
bool CellNode::AddSubNode(CellNode* node)
{
	//如果是符号链接，，不允许有子项，只能有target;
	if (nodeType == LINK)
	{
		return false;
	}

	if (&node != NULL)
	{
		node->preLink = this;
		subCellNodeList.push_back(node);
		//更新当前节点的修改时间
		UpdateLastModifyTime();
		return true;
	}
	return false;
}

//从当前结点的子节点中移除特定节点，可以选择是否释放此节点
bool CellNode::RemoveSubNode(CellNode * node, bool release)
{
	auto new_end = remove(subCellNodeList.begin(), subCellNodeList.end(), node);

	if (new_end == subCellNodeList.end())
	{
		return true;
	}
	node->preLink = NULL;
	subCellNodeList.erase(new_end, subCellNodeList.end());
	if (release)
	{
		delete node;
	}
	UpdateLastModifyTime();
	return false;
}

void CellNode::RemoveFromPreSubList(bool release)
{
	if (preLink == NULL)
	{
		return;
	}
	preLink->RemoveSubNode(this, release);
}

list<CellNode*> CellNode::FilterSubNode(string whildcard)
{
	list<CellNode*> res;
	copy_if(subCellNodeList.begin(), subCellNodeList.end(), back_inserter(res), [&](CellNode* node) {return Tools::IsWildcardMatch(whildcard, node->GetCellName()); });
	return res;
}

CellNode * CellNode::GetParent()
{
	return preLink;
}

vector<char>& CellNode::Content()
{
	return content;
}

//找到指定节点
CellNode * CellNode::GetNode(const Path & path)
{
	vector<string> items = path.split();

	CellNode* curNode = this;

	for (size_t i = 0; i < items.size(); i++)
	{
		if (!curNode)
		{
			return NULL;
		}
		if (items[i] == ".")
			continue;
		if (items[i] == "..")
		{
			curNode = curNode->preLink;
			continue;
		}

		auto target = find_if(curNode->subCellNodeList.begin(), curNode->subCellNodeList.end(), [&](CellNode* child) {return child->GetCellName() == items[i]; });
		//返回的迭代器是否为超尾元素
		curNode = target == curNode->subCellNodeList.end() ? NULL : *target;
	}
	return curNode;
}

void CellNode::SetNodeType(FileNodeType type)
{
	nodeType = type;
}

FileNodeType CellNode::GetNodeType()
{
	return nodeType;
}

string CellNode::GetNodeTypeStr()
{
	if (nodeType == LINK)
	{
		return "<LINK>";
	}
	else if (nodeType == FOLD)
	{
		return "<FOLD>";
	}
	else
	{
		return "";
	}
}

void CellNode::SetCellName(string name)
{
	cellName = name;
}

void CellNode::UpdateLastModifyTime()
{
	time(&lastModifyTime);
}

time_t CellNode::GetlastModifyTime()
{
	return lastModifyTime;
}

void CellNode::SetLastModifyTime(time_t value)
{
	lastModifyTime = value;
}

Path CellNode::GetNodePath()
{
	list<CellNode*> nodePath;
	CellNode* cur = this;
	while (cur)
	{
		nodePath.push_front(cur);
		cur = cur->GetParent();
	}
	Path ret;
	for (auto it = nodePath.begin(); it != nodePath.end(); it++)
	{
		ret.append((*it)->GetCellName());
	}
	return ret;
}

bool CellNode::IsRootNode()
{
	
	return preLink == NULL && (cellName == "/" || cellName =="C:" || cellName == "c:");
}

string CellNode::Target()
{
	if (nodeType&LINK)
	{
		return string(content.begin(), content.end());
	}
	return "";
}

string CellNode::GetCellName()
{
	return cellName;
}


ostream & operator<<(ostream & output, CellNode & self)
{
	//在每一条有效数据前设置关卡

	//修改时间信息
	int guard = 0;
	output.write((char*)&guard, sizeof(guard));
	output.write((char*)&self.lastModifyTime, sizeof(time_t));

	//节点类型信息
	guard = 0;
	output.write((char*)&guard, sizeof(guard));
	output.write((char*)&self.nodeType, sizeof(FileNodeType));

	//文件内容信息
	guard = 0;
	size_t count = self.content.size();
	output.write((char*)&guard, sizeof(guard));
	output.write((char*)&count, sizeof(size_t));
	if (self.content.size() > 0)
	{
		//将节点内容写入到文件中，写入大小为内容总大小
		output.write(&self.content.front(), self.content.size());
	}

	//节点名称信息
	guard = 0;
	count = self.GetCellName().size();
	output.write((char*)&guard, sizeof(guard));
	output.write((char*)&count, sizeof(size_t));
	output.write(&self.cellName.front(), count);


	//子节点信息
	guard = 0;
	count = self.subCellNodeList.size();
	output.write((char*)&guard, sizeof(guard));
	output.write((char*)&count, sizeof(size_t));

	for (auto itera = self.subCellNodeList.begin(); itera != self.subCellNodeList.end(); itera++)
	{
		CellNode* node = *itera;
		output << *node;
	}
	//循环输出
	return output;
}

istream & operator>>(istream & input, CellNode & self)
{
	// TODO: 在此处插入 return 语句

	//修改时间信息
	int guard;
	input.read((char*)&guard, sizeof(guard));
	if (guard == 0)
	{
		input.read((char*)&self.lastModifyTime, sizeof(time_t));
	}


	//节点类型信息
	input.read((char*)&guard, sizeof(guard));
	if (guard == 0)
	{
		input.read((char*)&self.nodeType, sizeof(FileNodeType));
	}
	
	size_t count =0;
	//读取节点内容信息
	input.read((char*)&guard, sizeof(guard));
	if (guard == 0)
	{
		input.read((char*)&count, sizeof(size_t));
	}
	if (count > 0)
	{
		self.content.resize(count);
		input.read(&self.content.front(), count);
	}


	//节点名称信息
	count = 0;
	input.read((char*)&guard, sizeof(guard));
	if (guard == 0)
	{
		input.read((char*)&count, sizeof(size_t));
	}
	if (count > 0)
	{
		self.cellName.resize(count);
		input.read(&self.cellName.front(), count);
	}

	//子节点信息
	count = 0;
	input.read((char*)&guard, sizeof(guard));
	if (guard == 0)
	{
		input.read((char*)&count, sizeof(size_t));
	}
	for (size_t i = 0; i < count; i++)
	{
		CellNode* node = new CellNode();
		input >> *node;
		if (node->cellName.empty())
		{
			return input;
		}
		self.AddSubNode(node);
	}
	//循环读取
	return input;
}
#include "ClsCmd.h"

bool ClsCmd::Execute(VirtualDiskInside * virtualdiskInside)
{
	system("cls");
	return true;
}
#include "CmdParameters.h"
#include <iterator>
#include <algorithm>
#include "MyString.h"

void CmdParameters::SetPathCount(int min, int max)
{
	min_pathNum = min;
	max_pathNum = max;
}

//将用户输入分解为命令参数和命令路径
bool CmdParameters::SplitUserInput(string & userInput)
{
	vector < pair<string, bool>> items = SplitToWordBySpace(userInput);
	//不再处理命令名
	for (size_t i = 1; i < items.size(); i++)
	{
		string &word = items[i].first;
		bool inquote = items[i].second;

		if (word.empty())
		{
			continue;
		}
		//如果带有引号
		if (inquote)
		{
			m_pathItems.push_back(word);
		}
		else if (word[0] == '/' && word.size() >= 2 && word.size() <= 3)
		{
			//当前解析到的是参数
			string tmp = word;
			transform(word.begin(), word.end(), tmp.begin(), ::tolower);
			m_parsedOptions.insert(tmp);
		}
		else
		{
			m_pathItems.push_back(word);
		}
	}

	set<string> opAdditional;
	//将命令中包含的，系统没有定义的参数，放入参数set中
	set_difference(m_parsedOptions.begin(), m_parsedOptions.end(), m_definedOptions.begin(), m_definedOptions.end(), inserter(opAdditional, opAdditional.begin()));

	//如果用户输入的有系统未定义的参数，返回
	if (!opAdditional.empty())
	{
		return false;
	}
	if ((int)m_pathItems.size() < min_pathNum)
	{
		return false;
	}
	if (max_pathNum >= 0 && (int)m_pathItems.size() > max_pathNum)
	{
		return false;
	}
	return true;
}

vector<pair<string, bool>> CmdParameters::SplitToWordBySpace(string & input)
{
	vector<pair<string, bool>> ret;
	string word;
	bool inquote = false;

	for (size_t cur = 0; cur < input.size(); ++cur)
	{
		if (input[cur] == '\"')
		{
			if (!inquote)
			{
				inquote = true;
			}
			else
			{
				inquote = false;
				continue;
				/*if (!StrProcess::stripspace(word).empty())
				{
					ret.push_back(make_pair(word, true));
				}
				word.clear();*/
			}
			continue;
		}//在不遇到下一个引号之前直接执行continue，
		if (inquote)
		{
			word.push_back(input[cur]);
			continue;
		}//引号结束之后再继续执行
		if (isspace(input[cur]))
		{
			if (!StrProcess::stripspace(word).empty())
			{
				ret.push_back(make_pair(word, false));
			}
			word.clear();
		}
		else
		{
			word.push_back(input[cur]);
		}
	}
	//将最后一项放入ret中
	if (!inquote)
	{
		if (!StrProcess::stripspace(word).empty())
		{
			ret.push_back(make_pair(word, false));
		}
		word.clear();
	}

	return ret;
}
#include "Command.h"

bool Command::Execute(VirtualDiskInside * virtualdisk)
{
	return false;
}#include "CommandFactory.h"
#include <iostream>
#include "MyString.h"

#include "ClsCmd.h"

#include"CdCmd.h"
#include "DirCmd.h"


#include"MdCmd.h"
#include "DelCmd.h"
#include "RdCmd.h"
#include "TouchCmd.h"

#include "MklinkCmd.h"
#include "RenCmd.h"
#include "MoveCmd.h"
#include "CopyCmd.h"

#include "SaveCmd.h"
#include "LoadCmd.h"
CommandFactory::CommandFactory()
{
}

CommandFactory::~CommandFactory()
{
	delete command;
}

Command * CommandFactory::CreatCommand(string cmd)
{
	//先将命令置空，方便下面判断返回
	command = NULL;
	vector<string> items = StrProcess::SplitNoEmpty(cmd, ' ');
	if (items.empty())
	{
		return NULL;
	}
	CmdTypeAnalyse(items[0]);
	switch (commandType)
	{
	case clsCmd:
		command = new ClsCmd();
		break;

	case cdCmd:
		command = new CdCmd();
		break;
	case saveCmd:
		command = new SaveCmd();
		break;
	case loadCmd:
		command = new LoadCmd();
		break;

	case dirCmd:
		command = new DirCmd();
		command->cmdParaCollection.m_definedOptions.insert("/s");
		command->cmdParaCollection.m_definedOptions.insert("/ad");
		break;
	case touchCmd:
		command = new TouchCmd();
		break;
	case rdCmd:
		command = new RdCmd();
		command->cmdParaCollection.m_definedOptions.insert("/s");
		break;
	case delCmd:
		command = new DelCmd();
		command->cmdParaCollection.m_definedOptions.insert("/s");
		break;
	case mdCmd:
		command = new MdCmd();
		break;

	case renCmd:
		command = new RenCmd();
		break;
	case moveCmd:
		command = new MoveCmd();
		break;
	case copyCmd:
		command = new CopyCmd();
		break;
	case mklinkCmd:
		command = new MklinkCmd();
		command->cmdParaCollection.m_definedOptions.insert("/d");
		break;

	default:
		//命令不存在 - 将临时保存的用户输入命令输出
		std::cout << outputMsg.Command_Illegal << "  userInput : " << cmd << std::endl;
		break;
	}

	if (!command)
	{
		cout << "命令创建失败";
		return false;
	}
	//设置命令所支持的路径数量
	SetCmdPathCount();
	//解析用户输入，将得到的参数及路径放入到命令参数集合中
	if (!command->cmdParaCollection.SplitUserInput(cmd))
	{
		cout << "命令参数或路径错误 " << endl;
		return false;
	}
	return command;
}

//根据cmdElent中的命令字符串，分析出命令ID
int CommandFactory::CmdTypeAnalyse(string cmdName)
{

	commandType = -1;

	for (int i = 0; i < sizeof(outputMsg.CommandCollection) / sizeof(outputMsg.CommandCollection[0]); i++)
	{
		if (cmdName == outputMsg.CommandCollection[i])
		{
			commandType = i;
		}
	}
	return commandType;
}

void CommandFactory::SetCmdPathCount()
{
	//设置命令可支持的路径数量
	if (commandType == clsCmd)
	{
		command->cmdParaCollection.SetPathCount(0, 0);
	}
	if (commandType == cdCmd)
	{
		command->cmdParaCollection.SetPathCount(0, 1);
	}
	if (commandType == dirCmd)
	{
		command->cmdParaCollection.SetPathCount(0, -1);
	}
	if (commandType == saveCmd || commandType == loadCmd)
	{
		command->cmdParaCollection.SetPathCount(1, 1);
	}
	if (commandType == touchCmd || commandType == rdCmd || commandType == delCmd || commandType == mdCmd)
	{
		command->cmdParaCollection.SetPathCount(1, -1);
	}
	if (commandType == copyCmd  || commandType == renCmd || commandType == mklinkCmd)
	{
		command->cmdParaCollection.SetPathCount(2, 2);
	}
	if (commandType == moveCmd)
	{
		command->cmdParaCollection.SetPathCount(1, 2);
	}
}

#include "Common.h"
#include"MyString.h"
#include <algorithm>



bool Tools::isWildcard(const string & pattern)
{
	if (pattern.find('*') != string::npos)
	{
		return true;
	}
	else if (pattern.find('?') != string::npos)
	{
		return true;
	}
	return false;
}

bool Tools::IsWildcardMatch(const string & wildcard, const string & str)
{
	string pattern;
	for (size_t i = 0; i < wildcard.size(); ++i)
	{
		if (wildcard[i] == '?')
		{
			pattern += ".?";
		}
		else if (wildcard[i] == '*')
		{
			pattern += ".*";
		}
		else
		{
			pattern += wildcard[i];
		}
	}

	return regex_match(str, regex(pattern));
}

bool Tools::IsLegalPathName(const string & pathName)
{
	string temp = pathName;
	if (StrProcess::stripspace(temp).empty())
	{
		return false;
	}
	string IlegalChar = "\\/:*?\"<>|";
	if (any_of(pathName.begin(), pathName.end(), [&](char c) {return IlegalChar.find(c) != string::npos; }))
	{
		return false;
	}
	return true;
}

bool Tools::IsLegalFileName(const string & filename)
{
	if (!IsLegalPathName(filename))
	{
		return false;
	}
	if (filename == ".")
	{
		return false;
	}
	if (filename == "..")
	{
		return false;
	}

	return true;
}
#define _CRT_SECURE_NO_WARNINGS
#include "CopyCmd.h"
#include "MyString.h"
#include "VirtualDiskInside.h"
#include <io.h>

//本命令要支持从物理磁盘拷贝内容

//四种拷贝方式
//V-R
//R-V
//V-V
//R-R

//第一个路径存放着源路径信息	支持通配符
//第二个路径存放着目标路径信息		支持通配符


//得到所有待操作路径
//用户输入的是真实路径	
	//输入的路径中不包括通配符
		//是一个正常的文件
		//是一个文件夹,将文件夹中的所有文件节点放入待操作列表
	//含有通配符
		//得到其父级路径，在父级路径中进行筛选

//用户输入的不是真实路径	
	//输入的路径中不包括通配符
		//是一个正常的文件
		//是一个文件夹,将文件夹中的所有文件节点放入待操作列表
	//含有通配符
		//得到其父级路径，在父级路径中进行筛选



//得到待操作列表



bool CopyCmd::Execute(VirtualDiskInside * virtualdisk)
{
	m_VirtualDisk = virtualdisk;
	vector<string> pathItems = cmdParaCollection.m_pathItems;
	Path srcPath(pathItems[0]);
	Path dstPath(pathItems[1]);



	//首先找到所有的待操作文件，放到路径链表中
	vector<Path> allsrcPath;
	//用户输入的是真实路径
	if (srcPath.IsReal())
	{
		//输入的路径中不包括通配符
		if (!Tools::isWildcard(srcPath.split().back()))
		{
			_finddata_t findData;
			intptr_t fileHandle = _findfirst(srcPath.str().c_str(), &findData);

			if (fileHandle == -1)
			{
				//查找失败，可能是路径出错
				return false;
			}
			if (findData.attrib &_A_ARCH)
			{
				//是一个正常的文件
				allsrcPath.push_back(srcPath);
			}
			else if (findData.attrib & _A_SUBDIR)
			{
				//是一个文件夹,将文件夹中的所有文件节点放入待操作列表
				fileHandle = _findfirst(srcPath.Self().append("*").str().c_str(), &findData);
				do
				{
					if (string(findData.name) == "." || string(findData.name) == "..")
					{
						continue;
					}
					if (findData.attrib & _A_SUBDIR)
					{
						continue;
					}
					allsrcPath.push_back(srcPath.Self().append(findData.name));

				} while (_findnext(fileHandle, &findData) == 0);
			}
		}
		else
		{
			//含有通配符
			_finddata_t findData;
			intptr_t fileHandle = _findfirst(srcPath.str().c_str(), &findData);

			if (fileHandle == -1)
			{
				//查找失败，可能是路径出错
				return false;
			}
			do
			{
				if (string(findData.name) == "." || string(findData.name) == "..")
				{
					continue;
				}
				if (findData.attrib & _A_SUBDIR)
				{
					continue;
				}
				if (!Tools::IsWildcardMatch(srcPath.split().back(), findData.name))
				{
					//再判断一次得到文件列表中当前文件是否匹配用户输入的通配符
					continue;
				}
				allsrcPath.push_back(srcPath.Self().append("..").append(findData.name));

			} while (_findnext(fileHandle, &findData) == 0);
		}
	}
	else
	{
		//不是真实路径
		if (!Tools::isWildcard(srcPath.split().back()))
		{
			//输入的路径中不包括通配符
			CellNode* node = m_VirtualDisk->GetNodeByPath(srcPath);
			if (node)
			{
				node = m_VirtualDisk->LookingForTaget(node);
				//路径指向节点是一个文件，将此文件的路径放入待复制列表
				if (node->GetNodeType()&FileNodeType::FILE_CUSTOM)
				{
					allsrcPath.push_back(node->GetNodePath());
				}
				else
				{
					//路径指向的节点是一个文件夹，将文件夹中的所有文件节点放入待操作列表
					list<CellNode*> children = node->FilterSubNode("*");
					for (auto itera = children.begin(); itera != children.end(); itera++)
					{
						if ((*itera)->GetNodeType()&FileNodeType::FILE_CUSTOM)
						{
							allsrcPath.push_back(m_VirtualDisk->LookingForTaget(*itera)->GetNodePath());
						}
					}

				}
			}
			else
			{
				m_VirtualDisk->LogMsgToConsole("路径不存在");
			}
		}
		else
		{
			//含有通配符
			//得到其父级路径，在父级路径中进行筛选
			CellNode* dir = m_VirtualDisk->GetNodeByPath(srcPath.Self().append(".."));
			if (dir)
			{
				dir = m_VirtualDisk->LookingForTaget(dir);
				//在父级路径下筛选文件节点，放入到待操作列表
				if (dir)
				{
					list<CellNode*> children = dir->FilterSubNode(srcPath.split().back());
					for (auto itera = children.begin(); itera != children.end(); itera++)
					{
						if ((*itera)->GetNodeType()&FileNodeType::FILE_CUSTOM)
						{
							allsrcPath.push_back(m_VirtualDisk->LookingForTaget(*itera)->GetNodePath());
						}
					}
				}
			}
			else
			{
				m_VirtualDisk->LogMsgToConsole("路径不存在");
			}
		}
	}


	if (allsrcPath.empty())
	{
		//没有要处理的文件
		return true;
	}
	for (size_t i = 0; i < allsrcPath.size(); i++)
	{
		Path& src(allsrcPath[i]);
		if (Tools::isWildcard(dstPath.split().back()))
		{
			//目标路径中有通配符
			string name;

			if (dstPath.split().back() == "*" || dstPath.split().back() == "*.*")
			{
				name = src.FileName();
			}
			else
			{
				string ret = dstPath.split().back();
				StrProcess::replace(ret, "*", src.Title());
				StrProcess::replace(ret, "?", src.Title());//此处可能匹配不对，*匹配多个，？匹配一个
				m_VirtualDisk->LogMsgToConsole("此处可能匹配不对，*匹配多个，？匹配一个");
				name = ret;
			}

			Path tempdstpath = dstPath.Parent().append(name);
			Copy(src, tempdstpath, true);
		}
		else
		{
			//目标路径中没有通配符
			Copy(src, dstPath, i == 0);
		}
	}
	return true;
}

void CopyCmd::Copy(Path & src, Path & dst, bool first)
{
	if (dst.IsReal())
	{
		//R-R
		if (src.IsReal())
		{
			string cmd = StrProcess::sstr("copy \"%s\" \"%s\"", src.str().c_str(), dst.str().c_str());	//交由系统执行
			system(cmd.c_str());
		}
		else
		{	//V-R
			_finddata_t findData;
			intptr_t handle = _findfirst(dst.str().c_str(), &findData);

			if (handle == -1)
			{
				//没有相同的文件
				CopyNodeToReal(src, dst);
			}
			else if (findData.attrib & _A_RDONLY)
			{
				m_VirtualDisk->LogMsgToConsole("文件只读，只能作为复制源");
				return;
			}
			else if (findData.attrib & _A_SUBDIR)
			{
				//将该文件拷贝到dst指向的文件夹中，文件名成与原名称相同
				Copy(src, dst.Self().append(src.FileName()), true);
			}
			else
			{
				if (first)
				{
					//如果文件存在则 清空其内容；   ？？？？？为什么无效？
					FILE* fout = fopen(dst.str().c_str(), "wb");
					fclose(fout);
				}
				CopyNodeToReal(src, dst);

			}
		}
	}
	else   //dst is virtualdiskNode
	{
		CellNode* dstNode = m_VirtualDisk->GetNodeByPath(dst);
		if (!dstNode)
		{
			//创建一个目标节点
			string filenametemp = dst.FileName();
			if (filenametemp.empty())
			{
				return;
			}
			CellNode* nodeprelink = m_VirtualDisk->GetNodeByPath(dst.Self().append(".."));
			nodeprelink = m_VirtualDisk->LookingForTaget(nodeprelink);
			if (!nodeprelink)
			{
				m_VirtualDisk->LogMsgToConsole("路径不存在");
				return;
			}
			CellNode* node = new CellNode();
			node->SetCellName(dst.FileName());
			node->SetNodeType(FileNodeType::FILE_CUSTOM);
			nodeprelink->AddSubNode(node);


			if (!node)
			{
				//创建失败，返回
				return;
			}
			else if(src.IsReal())
			{
				//创建成功，返回
				CopyRealToNode(src, node);
			}
			else
			{
				//src已经经过判断，可以直接使用
				//node也经过判断，可以直接使用
				CellNode* srcNode = m_VirtualDisk->GetNodeByPath(src);
				if (!srcNode) { return; }
				node->Content().insert(node->Content().end(), srcNode->Content().begin(), srcNode->Content().end());
				node->SetLastModifyTime(srcNode->GetlastModifyTime());
			}
		}
		else if (dstNode->GetNodeType()&FileNodeType::FOLD)
		{
			CellNode* node = m_VirtualDisk->LookingForTaget(dstNode);
			if (!node)
			{
				m_VirtualDisk->LogMsgToConsole("路径不存在");
				return;
			}
			//在该文件夹末尾添加要复制的文件名，再次进入Copy命令，执行创建节点的语句
			node->GetNodePath();
			Copy(src, node->GetNodePath().Self().append(src.FileName()), true);
			//Copy(src, dst.Self().append(src.FileName()), true);
		}
		else if (dstNode->GetNodeType()&FileNodeType::FILE_CUSTOM)
		{

			//当前节点是文件，或者指向文件的符号链接，，，找到最终节点进行操作
			CellNode* prelink = dstNode;
			CellNode* tempNode = m_VirtualDisk->LookingTarget(prelink);
			while (tempNode&& tempNode != prelink)
			{
				prelink = tempNode;
				tempNode = m_VirtualDisk->LookingTarget(tempNode);
			}

			//得到最终节点 ，最终节点若不存在，则说明其父节点是文件节点，执行拷贝
			if (!tempNode)
			{
				Path tempdstpath = prelink->Target();
				Copy(src, tempdstpath, first);
			}
			else if (m_VirtualDisk->LookingForTaget(m_VirtualDisk->GetNodeByPath(src)) == tempNode)
			{
				m_VirtualDisk->LogMsgToConsole("源节点与目标节点相同");
			}
			else
			{
				if (first)
				{
					tempNode->Content().clear();
				}
				if (src.IsReal())
				{
					CopyRealToNode(src, tempNode);
				}
				else
				{
					//源节点和目标节点都已经过判断
					CellNode* srcNode = m_VirtualDisk->GetNodeByPath(src);
					if (!srcNode) { return; }
					tempNode->Content().insert(tempNode->Content().end(), srcNode->Content().begin(), srcNode->Content().end());
					tempNode->SetLastModifyTime(srcNode->GetlastModifyTime());
				}
			}
		}
		else
		{
			m_VirtualDisk->LogMsgToConsole("情况不对，撤退");
			return;
		}
	}
}



void CopyCmd::CopyNodeToReal(Path&src, Path& dst)
{
	//已经对srcnode经过判断，此处可直接使用
	CellNode* nodesrc = m_VirtualDisk->GetNodeByPath(src);
	if (!nodesrc){return;}
	
	//如果文件不存在则创建该文件， 并以二进制只写方式打开该文件
	FILE* fout = fopen(dst.str().c_str(), "ab");
	if (!fout)
	{
		m_VirtualDisk->LogMsgToConsole("本地文件打开失败");
		return;
	}
	//将源节点中的数据内容以字符为单位写入到真实文件中去
	if (nodesrc->Content().size() > 0)
	{
		fwrite(&nodesrc->Content().front(), 1, nodesrc->Content().size(), fout);
	}
	fclose(fout);
}

void CopyCmd::CopyRealToNode(Path&src, CellNode* dstNode)
{
	if (!dstNode) { return; }
	//读取文件流写入到虚拟节点的content中
	//以二进制只读方式打开该文件
	FILE* fin = fopen(src.str().c_str(), "rb");
	if (!fin)
	{
		m_VirtualDisk->LogMsgToConsole("本地文件打开失败");
		return;
	}
	char buff[1024];
	//不到文件结尾的话就一直继续读取
	while (!feof(fin))
	{
		size_t count = fread(buff, 1, sizeof(buff), fin);
		dstNode->Content().insert(dstNode->Content().end(), buff, buff + count);
	}
	fclose(fin);
}


#include "DelCmd.h"
#include "Path.h"
#include "Common.h"
#include "VirtualDiskInside.h"
#include "MyString.h"


bool DelCmd::Execute(VirtualDiskInside * virtualdisk)
{
	m_VirtualDisk = virtualdisk;
	vector<string> pathItems = cmdParaCollection.m_pathItems;
	if (pathItems.empty())
	{
		return false;
		//路径是空的
		//命令语法不正确，最少一条路径，path中已经经过判断
	}
	//对每条路径分别处理
	for (size_t i = 0; i < pathItems.size(); i++)
	{
		CellNode* node = NULL;
		string wildcard;
		Path tempPath(pathItems[i]);

		//首先过滤不存在的项目

		if (Tools::isWildcard(tempPath.split().back()))
		{
			wildcard = tempPath.split().back();

			CellNode* tempNode = m_VirtualDisk->GetNodeByPath(tempPath.Self().append(".."));
			if (!tempNode)
			{
				//没有相应的父级文件
				continue;
			}
			else if (!(tempNode->GetNodeType()&FOLD))
			{
				//没有找到对应的文件
				continue;
			}
			node = tempNode;
		}
		else
		{
			node = m_VirtualDisk->GetNodeByPath(tempPath);
			if (!node)
			{
				//没有找到对应的文件
				continue;
			}
		}

		//开始处理
		if (wildcard.empty())
		{
			wildcard = "*";
		}
		DisPatchPathItem(node, wildcard);
	}

	return true;
}


void DelCmd::DisPatchPathItem(CellNode * node, const string & wildcard)
{
	if (node->GetNodeType()&FILE_CUSTOM && node->GetNodeType()&LINK)
	{
		RemoveFoldLinkFile(node->GetParent(), m_VirtualDisk->LookingForTaget(node->GetParent()), node->GetCellName());
	}
	else if (node->GetNodeType()&FOLD && node->GetNodeType()&LINK)
	{
		CellNode* target = m_VirtualDisk->LookingForTaget(node);
		if (!target)
		{
			m_VirtualDisk->LogMsgToConsole("找不到文件");
		}
		else
		{
			RemoveFoldLinkFile(target, target, wildcard);
		}
	}
	else if (node->GetNodeType()&FILE_CUSTOM)
	{
		RemoveFoldLinkFile(node->GetParent(), node->GetParent(), node->GetCellName());
	}
	else if (node->GetNodeType()&FOLD)
	{
		RemoveFoldLinkFile(node, node, wildcard);
	}
	else
	{
		m_VirtualDisk->LogMsgToConsole("如果此条信息被打印，说明程序存在意外情况，详细判断请见：bool DelCmd::Execute");
		return;
	}
}

void DelCmd::RemoveFoldLinkFile(CellNode * fold, CellNode * deep, const string & filesName)
{
	//是否是匹配所有文件
	if (filesName == "*" || filesName == "*.*")
	{
		while (true)
		{
			//询问用户是否删除当前路径下的本项内容
			//向Virtual Disk请求操作
			string answer = m_VirtualDisk->AskForUserInput(StrProcess::sstr("%s, 是否确认(Y/N)?", fold->GetNodePath().str().c_str()));

			string result;

			transform(answer.begin(), answer.end(), answer.begin(), tolower);
			if (answer == "y" || answer == "yes")
			{
				break;
			}
			else if (answer == "n" || answer == "no")
			{
				return;
			}
		}
	}

	list<CellNode*> children = deep->FilterSubNode(filesName);
	for (auto itera = children.begin(); itera != children.end(); itera++)
	{
		if ((*itera)->GetNodeType()&FILE_CUSTOM)
		{
			//如果用户有循环删除的参数，则删除时提醒当前操作对象
			if (cmdParaCollection.m_parsedOptions.find("/s") != cmdParaCollection.m_parsedOptions.end())
			{
				m_VirtualDisk->LogMsgToConsole(StrProcess::sstr("删除文件 - %s", (*itera)->GetNodePath().str().c_str()));
				//删除这个节点
			}
			//无法确定删除改点之后是否会影响整个list
			(*itera)->RemoveFromPreSubList(true);
			//删除掉这个节点
		}
	}

	//判断是否循环处理子节点
	if (cmdParaCollection.m_parsedOptions.find("/s") != cmdParaCollection.m_parsedOptions.end())
	{
		list<CellNode*> children = deep->FilterSubNode("*");
		for (auto itera = children.begin(); itera != children.end(); itera++)
		{
			if ((*itera)->GetNodeType()&FOLD)
			{
				DisPatchPathItem(*itera, filesName);
			}
		}
	}
}
#define _CRT_SECURE_NO_WARNINGS

#include "DirCmd.h"
#include "MyString.h"
#include "VirtualDiskInside.h"
bool DirCmd::Execute(VirtualDiskInside * virtualdisk)
{
	m_VirtualDisk = virtualdisk;


	vector<string> pathItems = cmdParaCollection.m_pathItems;
	//如果用户没有输入路径,非递归打印当前路径
	if (pathItems.empty())
	{
		pathItems.push_back(".");
	}

	for (size_t i = 0; i < pathItems.size(); i++)
	{
		if (cmdParaCollection.m_parsedOptions.find("/s") != cmdParaCollection.m_parsedOptions.end())
		{
			//递归输出
			RecursionPrintItem(pathItems[i]);
		}
		else
		{
			PrintItem(pathItems[i]);
			//输出本节点的子节点
		}
	}


	//计算本次的总输出信息
	size_t filecount = 0;
	size_t foldcount = 0;
	size_t totalsize = 0;
	CountSummary(totalNode, filecount, foldcount, totalsize);

	//如果系统没有要求递归输出 ********************************************************************************待修改
	if (!(cmdParaCollection.m_parsedOptions.find("/s") != cmdParaCollection.m_parsedOptions.end()))
	{
		m_VirtualDisk->LogMsgToConsole(StrProcess::sstr("%16d 个目录", (int)foldcount));
	}
	else
	{
		if (filecount == 0 && foldcount == 0)
		{
			m_VirtualDisk->LogMsgToConsole("找不到相应的文件");
		}
		else
		{
			m_VirtualDisk->LogMsgToConsole(StrProcess::sstr("\n     所列文件总数:\n%16d 个文件%s 字节\n%16d个目录", (int)filecount, NumberToString(totalsize, 15).c_str(), foldcount));
		}
	}

	return true;
}


void DirCmd::RecursionPrintItem(const Path & path)
{
	//是否是使用通配符的路径信息
	if (Tools::isWildcard(path.split().back()))
	{
		CellNode* prelink = m_VirtualDisk->GetNodeByPath(path.Parent());
		CheckDirWithFiles(prelink, path.split().back());
	}
	else
	{
		CellNode* node = m_VirtualDisk->GetNodeByPath(path);
		//如果路径所指向的节点不存在，则不进行输出，直接返回
		if (!node)
		{
			m_VirtualDisk->LogMsgToConsole("该位置可能出错：void DirCmd::RecursionPrintItem(const Path & path)  FormatCheck.noexist ");
			return;
		}
		else if (node->GetNodeType()& LINK && node->GetNodeType()& FOLD)
		{
			//路径信息是指向文件夹的符号链接 输出目标文件夹下的所有文件（文件夹）信息，若用户输入相关参数，则只显示对应信息
			//没有找到符号链接的目标文件---------此时暂不处理失效的符号链接
			if (!m_VirtualDisk->LookingForTaget(node))
			{
				return;
			}
			CheckDirWithFiles(node, "*");
		}
		else if (node->GetNodeType() & LINK && node->GetNodeType() & FILE_CUSTOM)
		{
			//路径信息是指向文件的符号链接  --仅显示当前指向的文件的这一条信息
			if (!m_VirtualDisk->LookingForTaget(node))
			{
				return;
			}
			CheckDirWithFiles(node->GetParent(), node->GetCellName());
		}
		else if (node->GetNodeType()&FOLD)
		{
			//路径信息是指向文件夹的，输出目标文件夹下的所有信息
			CheckDirWithFiles(node, "*");
		}
		else if (node->GetNodeType()&FILE_CUSTOM)
		{
			//路径信息是指向文件的   找到其父节点，输出其信息 --仅显示当前指向的文件的这一条信息
			CheckDirWithFiles(node->GetParent(), node->GetCellName());
		}
	}
}

void DirCmd::PrintItem(const Path & path)
{
	if (Tools::isWildcard(path.split().back()))
	{
		CellNode* parent = m_VirtualDisk->GetNodeByPath(path.Parent());
		if (parent)
		{
			CheckDirWithFiles(parent, path.split().back());
		}
		else
		{
			m_VirtualDisk->LogMsgToConsole("系统找不到指定的路径");
		}
	}
	else
	{
		CellNode* node = m_VirtualDisk->GetNodeByPath(path);
		if (!node)
		{
			CellNode* parent = m_VirtualDisk->GetNodeByPath(path.Parent());
			if (parent)
			{
				CheckDirWithFiles(parent, path.split().back());
			}
			else
			{
				m_VirtualDisk->LogMsgToConsole("系统找不到指定的路径");
			}
		}
		else if (node->GetNodeType()& LINK && node->GetNodeType()& FOLD)
		{
			if (!m_VirtualDisk->LookingForTaget(node))
			{
				m_VirtualDisk->LogMsgToConsole("系统找不到指定的路径");
				return;
			}
			CheckDirWithFiles(node, "*");
		}
		else if (node->GetNodeType() & LINK && node->GetNodeType() & FILE_CUSTOM)
		{
			//路径信息是指向文件的符号链接  --仅显示当前指向的文件的这一条信息
			if (!m_VirtualDisk->LookingForTaget(node))
			{
				m_VirtualDisk->LogMsgToConsole("系统找不到指定的路径");
				return;
			}
			CheckDirWithFiles(node->GetParent(), node->GetCellName());
		}
		else if (node->GetNodeType()&FOLD)
		{
			//路径信息是指向文件夹的，输出目标文件夹下的所有信息
			CheckDirWithFiles(node, "*");
		}
		else if (node->GetNodeType()&FILE_CUSTOM)
		{
			//路径信息是指向文件的   找到其父节点，输出其信息 --仅显示当前指向的文件的这一条信息
			CheckDirWithFiles(node->GetParent(), node->GetCellName());
		}
	}
}

void DirCmd::CheckDirWithFiles(CellNode * node, const string & filesname)
{
	if (!node)
	{
		return;
	}

	//想办法记录一下已经处理过的文件（或文件夹），对相同的任务不重复进行，防止循环链接的无尽输出
	if (m_proCessed.find(ProcessedInfo{ node , filesname }) != m_proCessed.end())
	{
		return;
	}
	m_proCessed.insert(ProcessedInfo{ node , filesname });

	//输出当前目录的标头总括
	m_VirtualDisk->LogMsgToConsole(StrProcess::sstr("%s 的目录\n", node->GetNodePath().str().c_str()));

	//如果是符号链接，则找到其目标节点，然后开始处理
	//如果非符号链接，则返回其本身，继续处理
	node = m_VirtualDisk->LookingForTaget(node);
	if (!node) { return; }

	//根据文件名进行筛选当前节点的子节点然后进行输出处理
	list<CellNode*> children = node->FilterSubNode(filesname);
	if (Tools::IsWildcardMatch(filesname, "."))
	{
		//输出一个信息
		m_VirtualDisk->LogMsgToConsole(MakeOneOutput(node, "."));
	}
	if (Tools::IsWildcardMatch(filesname, "..") && !node->IsRootNode())
	{
		//MakeOneOutput(node->GetParent(), "..");
		m_VirtualDisk->LogMsgToConsole(MakeOneOutput(node->GetParent(), ".."));
	}


	for (auto it = children.begin(); it != children.end(); it++)
	{
		//如果系统只要求输出文件夹，则跳过当前文件类型不是fold的选项
		if (cmdParaCollection.m_parsedOptions.find("/ad") != cmdParaCollection.m_parsedOptions.end() && !((*it)->GetNodeType() & FOLD))
		{
			continue;
		}
		m_VirtualDisk->LogMsgToConsole(MakeOneOutput(*it, (*it)->GetCellName()));
	}

	//截至当前，已经处理完一个文件夹*********************************************************************
	oneFoldSummary();
	totalNode.insert(totalNode.end(), oneFoldNode.begin(), oneFoldNode.end());
	oneFoldNode.clear();

	//想办法记录处理过的数量
	//统计信息

	if (cmdParaCollection.m_parsedOptions.find("/s") != cmdParaCollection.m_parsedOptions.end())
	{
		list<CellNode*> children = node->FilterSubNode("*");

		for (auto it = children.begin(); it != children.end(); it++)
		{
			if ((*it)->GetNodeType()& FOLD)
			{
				RecursionPrintItem((*it)->GetNodePath().append(filesname));
			}
		}
	}
}

string DirCmd::MakeOneOutput(CellNode * node, const string & name)
{
	time_t rawtime = node->GetlastModifyTime();

	struct tm * timeinfo = localtime(&rawtime);

	char buff[128] = { 0 };

	//日期与时间 两个空格，   时间与类型，四个空格
	strftime(buff, sizeof(buff), "%G/%m/%d  %H:%M    ", timeinfo);

	string res = buff;

	if ((node->GetNodeType()& FILE_CUSTOM) && !(node->GetNodeType()& LINK))
	{
		res += NumberToString(node->Content().size(), 14);
	}
	else
	{
		res += StrProcess::sstr("%-14s", node->GetNodeTypeStr().c_str());
	}

	res += " ";
	res += name;

	oneFoldNode.push_back(node);
	//不在输出其链接信息
	return res;
}

//将数字转化成指定格式的字符串
string DirCmd::NumberToString(size_t num, size_t length)
{
	list<char> retTmp;
	const string temp = StrProcess::sstr("%u", num);

	for (auto it = temp.rbegin(); it != temp.rend(); it++)
	{
		int diff = (int)distance(temp.rbegin(), it);
		if (diff > 0 && diff % 3 == 0)
		{
			retTmp.push_front(',');
		}
		retTmp.push_front(*it);
	}
	while (retTmp.size() < length)
	{
		retTmp.push_front(' ');
	}
	return string(retTmp.begin(), retTmp.end());
}

void DirCmd::oneFoldSummary()
{
	size_t fileCount = 0;
	size_t foldCount = 0;
	size_t totalSize = 0;

	CountSummary(oneFoldNode, fileCount, foldCount, totalSize);

	if (fileCount == 0 && foldCount == 0)
	{
		if (!(cmdParaCollection.m_parsedOptions.find("/s") != cmdParaCollection.m_parsedOptions.end()))
		{
			//该位置可能会无限循环
			m_VirtualDisk->LogMsgToConsole("找不到指定文件");
			m_VirtualDisk->LogMsgToConsole("该位置可能会无限循环：void DirCmd::oneFoldSummary()");
		}
	}
	else
	{
		//输出这一个文件夹的统计信息，然后继续循环    不输出文件夹的数量*********************************************************************************
		m_VirtualDisk->LogMsgToConsole(StrProcess::sstr("%s 个文件%s 字节", NumberToString(fileCount, 16).c_str(), NumberToString(totalSize, 15).c_str()));
	}
}

void DirCmd::CountSummary(const list<CellNode*>& nodes, size_t & files, size_t & dirs, size_t & sizes)
{
	//使用谓词函数进行数量计算
	//此处有待修改内容
	for (auto itera = nodes.begin(); itera != nodes.end(); itera++)
	{
		CellNode* tempNode = *itera;
		Path tempPath = tempNode->GetNodePath();

		if (Tools::isWildcard(tempPath.split().back()))
		{

		}
		else
		{
			if (!tempNode)
			{

			}
			else if (tempNode->GetNodeType()& LINK && tempNode->GetNodeType()& FOLD)
			{
				dirs++;
			}
			else if (tempNode->GetNodeType() & LINK && tempNode->GetNodeType() & FILE_CUSTOM)
			{
				files++;
			}
			else if (tempNode->GetNodeType()&FOLD)
			{
				dirs++;
			}
			else if (tempNode->GetNodeType()&FILE_CUSTOM)
			{
				files++;
				sizes += (int)tempNode->Content().size();
			}
		}
	}
}



#include "LoadCmd.h"
#include <fstream>
#include "VirtualDiskInside.h"
bool LoadCmd::Execute(VirtualDiskInside * virtualdisk)
{
	m_VirtualDisk = virtualdisk;

	//该命令直接收一条路径，必须为真实路径

	//创建一个节点用于接受从文件中读取的数据
	//将此节点设置为root节点，
		//如何处理源根节点？



	vector<string> pathItems = cmdParaCollection.m_pathItems;

	Path srcPath(pathItems[0]);

	if (!srcPath.IsReal())
	{
		m_VirtualDisk->LogMsgToConsole("不是真实路径");
		return false;
	}

	fstream fin;
	fin.open(srcPath.str(), ios::binary | ios::in);

	if (!fin)
	{
		m_VirtualDisk->LogMsgToConsole("文件打开失败");
		return false;
	}

	CellNode* rootNode = new CellNode();

	fin >> *rootNode;

	fin.close();


	if (rootNode->GetCellName().empty() || rootNode->GetCellName()!= "/")
	{
		m_VirtualDisk->LogMsgToConsole("读取失败");
		return false;
	}

	m_VirtualDisk->SetRootNode(rootNode);
	m_VirtualDisk->SetWorkingNode(rootNode);

	return true;
}

#include "MdCmd.h"
#include "VirtualDiskInside.h"
#include "Common.h"
//该位置判断可能出错
bool MdCmd::Execute(VirtualDiskInside* virtualdisk)
{
	vector<string> pathItems = cmdParaCollection.m_pathItems;
	for (size_t i = 0; i < pathItems.size(); i++)
	{
		//不处理绝对路径
		//对参数集合中的路径信息进行分解，首先将\替换为/， 然后按照/进行分解。分解为单个节点名称
		Path tempPath(pathItems[i]);

		if (tempPath.IsReal())
		{
			return false;
		}
		//得到路径的节点名称矢量组
		vector<string> items = tempPath.split();

		//判断是否是相对路径来确定当前节点
		CellNode * curNode = virtualdisk->GetNodeByPath(tempPath.StartNode());

		//开始寻路或者创建相应的文件夹
		for (size_t i = 0; i < items.size(); i++)
		{
			if (curNode == NULL)
			{
				return false;
			}
			//判断当前路径节点名称是否合法
			if (!Tools::IsLegalPathName(items[i]))
			{
				return false;
			}
			if (items[i] == "." || items[i] == "..")
			{
				curNode = curNode->GetNode(items[i]);
				continue;
			}

			//根据当前节点名称去寻找相应的节点
			CellNode* child = curNode->GetNode(items[i]);
			if (!child)
			{
				child = new CellNode();
				child->SetCellName(items[i]);
				child->SetNodeType(FOLD);
				curNode->AddSubNode(child);
				//将创建的节点置为当前节点，继续下一个用户输入节点的创建
				curNode = child;
			}
			else if (child->GetNodeType() & FOLD)
			{
				//如果child的类型为文件夹，则curNode = child ; 若类型为link，则curNode 等于 child的target
				curNode = virtualdisk->LookingForTaget(child);
				continue;
			}
			else
			{
				virtualdisk->LogMsgToConsole("已存在相同名称的文件");
				return false;
			}
		}
		return true;
	}
	return true;
}
#include "MklinkCmd.h"
#include "VirtualDiskInside.h"
#include "Path.h"
bool MklinkCmd::Execute(VirtualDiskInside * virtualdisk)
{
	m_VirtualDisk = virtualdisk;
	//在pathItems中保存着两个items，分别存有一个路径
	//得到目标节点的 路径、类型、名称信息 ， 存放到要建立的符号链接节点的content中。

	
	vector<string> pathItems = cmdParaCollection.m_pathItems;
	//首先要保证该vector中有两个路径信息。
	Path linkNodePath(pathItems[0]);
	Path targetNodePath(pathItems[1]);

	if (linkNodePath.FileName().empty())
	{
		m_VirtualDisk->LogMsgToConsole("文件名不合法，退出");
		return false;
	}

	if (virtualdisk->GetNodeByPath(linkNodePath))
	{
		m_VirtualDisk->LogMsgToConsole("创建的节点存在同名文件，退出");
		return false;
	}

	CellNode* targetNode = virtualdisk->GetNodeByPath(targetNodePath);
	if (!targetNode)
	{
		m_VirtualDisk->LogMsgToConsole("目标节点不存在，退出");
		return false;
	}
	if (cmdParaCollection.m_parsedOptions.find("/d") != cmdParaCollection.m_parsedOptions.end() && !(targetNode->GetNodeType()&FOLD))
	{
		m_VirtualDisk->LogMsgToConsole("目标文件必须是目录，退出");
		return false;
	}
	if (!(cmdParaCollection.m_parsedOptions.find("/d") != cmdParaCollection.m_parsedOptions.end()) && !(targetNode->GetNodeType()&FILE_CUSTOM))
	{
		m_VirtualDisk->LogMsgToConsole("目标文件必须是文件，退出");
		return false;
	}


	//判断结束，开始创建链接。

	//目标文件是否可以是符号链接？

	string filename = linkNodePath.FileName();
	//找到待创建路径的上级节点
	linkNodePath.append("..");

	CellNode* prelink = virtualdisk->GetNodeByPath(linkNodePath);

	if (!prelink)
	{
		return false;
	}

	//创建该节点
	CellNode* node = new CellNode();
	node->SetCellName(filename);
	prelink->AddSubNode(node);

	node->SetNodeType(FileNodeType(LINK |targetNode->GetNodeType()));

	//将目标节点的信息放到该节点的content中
	const string tempPathString = targetNode->GetNodePath().str();
	node->Content().assign(tempPathString.begin(), tempPathString.end());

	return true;
}
#include "MoveCmd.h"
#include "Path.h"
#include "VirtualDiskInside.h"
#include "MyString.h"

//得到 源路径	支持通配符
//得到目标路径	不支持通配符

//从源路径中得到待操作的文件列表（只包含文件）
	//若源路径指向文件夹
		
			//若目标路径为文件夹
			//若目标路径不存在
	//若源路径使用通配符
		//若匹配文件项目 < 1
			//移动或者覆盖
		//若匹配文件项目 > 1
			//若目标路径为文件夹
				//移动或者覆盖
			//若目标路径不存在
				//错误
	//若源路径指向普通文件
			//若目标路径为文件夹
			//若目标路径不存在

bool MoveCmd::Execute(VirtualDiskInside * virtualdisk)
{
	m_VirtualDisk = virtualdisk;
	needAsk = !(cmdParaCollection.m_parsedOptions.find("/y") != cmdParaCollection.m_parsedOptions.end());
	vector<string> pathItems = cmdParaCollection.m_pathItems;
	//copy和move命令支持单个路径，默认第二条路径为当前工作路径
	if (pathItems.size() == 1)
	{
		pathItems.push_back(".");
	}
	Path from(pathItems[0]);
	Path to(pathItems[1]);

	//其中有指向不同目录的符号链接文件，要找到这些符号链接文件的目标文件，加入待操作链表
	if (!Tools::IsLegalPathName(to.split().back()))
	{
		return false;
	}

	vector<Path> srcAllPath;
	if (Tools::isWildcard(from.split().back()))
	{
		CellNode* dir = m_VirtualDisk->GetNodeByPath(from.Self().append(".."));
		if (!dir)
		{
			//情况不对，退出
			m_VirtualDisk->LogMsgToConsole("情况不对，撤退");
			return false;
		}
		else
		{
			dir = m_VirtualDisk->LookingForTaget(dir);
			if (dir)
			{
				list<CellNode*> children = dir->FilterSubNode(from.split().back());
				for (auto it = children.begin(); it != children.end(); ++it)
				{
					if ((*it)->GetNodeType()&FileNodeType::FILE_CUSTOM) {
						srcAllPath.push_back(m_VirtualDisk->LookingForTaget(*it)->GetNodePath());
					}
				}
			}
		}
	}
	else
	{
		CellNode* node = m_VirtualDisk->GetNodeByPath(from);
		if (!node) {
			m_VirtualDisk->LogMsgToConsole("文件不存在");
			return false;
		}
		if (m_VirtualDisk->IfNodeBeUsing(node))
		{
			m_VirtualDisk->LogMsgToConsole("拒绝访问，父级目录正在被使用");
			return false;
		}
		srcAllPath.push_back(from);
	}

#pragma region pick截取

	//if (!Tools::isWildcard(from.split().back()))
	//{
	//	CellNode* node = m_VirtualDisk->GetNodeByPath(from);
	//	if (!node)
	//	{

	//	}
	//	else
	//	{
	//		node = m_VirtualDisk->LookingForTaget(node);
	//		if (node->GetNodeType()&FileNodeType::FILE_CUSTOM)
	//		{
	//			srcAllPath.push_back(node->GetNodePath());
	//		}
	//		else
	//		{
	//			list<CellNode*> children = node->FilterSubNode("*");
	//			for (auto it = children.begin(); it != children.end(); ++it)
	//			{
	//				if ((*it)->GetNodeType()&FileNodeType::FILE_CUSTOM) {
	//					srcAllPath.push_back(m_VirtualDisk->LookingForTaget(*it)->GetNodePath());
	//				}
	//			}
	//		}
	//	}
	//	
	//}
	//else
	//{
	//	CellNode* dir = m_VirtualDisk->GetNodeByPath(from.Self().append(".."));
	//	if (!dir)
	//	{

	//	}
	//	else
	//	{
	//		dir = m_VirtualDisk->LookingForTaget(dir);
	//		if (dir)
	//		{
	//			list<CellNode*> children = dir->FilterSubNode(from.split().back());
	//			for (auto it = children.begin(); it != children.end(); ++it)
	//			{
	//				if ((*it)->GetNodeType()&FileNodeType::FILE_CUSTOM) {
	//					srcAllPath.push_back(m_VirtualDisk->LookingForTaget(*it)->GetNodePath());
	//				}
	//			}
	//		}
	//	}
	//	
	//}


#pragma endregion

	if (srcAllPath.empty())
	{
		//没有待操作文件
		return true;
	}
	if (  srcAllPath.size()>1 && (!m_VirtualDisk->GetNodeByPath(to) || m_VirtualDisk->GetNodeByPath(to)->GetNodeType()&FileNodeType::FILE_CUSTOM))
	{
		m_VirtualDisk->LogMsgToConsole("目标节点不能是文件节点 或者不存在");
		return false;
	}

	for (auto itera = srcAllPath.begin(); itera != srcAllPath.end(); itera++)
	{
		MoveNode(m_VirtualDisk->GetNodeByPath(*itera), to);
	}	
	m_VirtualDisk->LogMsgToConsole(StrProcess::sstr("移动了%9d 个文件", srcAllPath.size()));	
	return false;
}


void MoveCmd::MoveNode(CellNode* from, Path& to)
{

	CellNode* dst = m_VirtualDisk->GetNodeByPath(to);
	if (!dst)
	{
		//如果目标路径不存在，且其有父节点
		CellNode* parent = m_VirtualDisk->GetNodeByPath(to.Parent());
		if (!parent)
		{
			//路径不存在
			return;
		}
		ConfirmThenMove(from, to);
	}
	else if (dst->GetNodeType()&FileNodeType::FOLD)
	{
		//如果目标节点存在，切问文件夹节点或者符号链接至文件夹的节点

		//得到目标文件夹，
		CellNode* node = m_VirtualDisk->LookingForTaget(dst);
		if (!node) {

			//路径不存在
			return;
		}
		else if (from == node)
		{
			//如果目标文件夹正在被访问
			m_VirtualDisk->LogMsgToConsole("拒绝访问，正在被使用");
			return;
		}
		else
		{
			//如果目标文件夹存在，而且没有被使用，则在此目标文件夹路径的末端，加上要移动的文件的名字。在移动时直接创建
			CellNode* cur = node->GetParent();
			while (cur)
			{
				if (cur == from)
				{
					m_VirtualDisk->LogMsgToConsole("拒绝访问，父级目录正在被使用");
					return;
				}
				cur = cur->GetParent();
			}
		}
		ConfirmThenMove(from, node->GetNodePath().append(from->GetCellName()));
	}
	else
	{
		//如果目标节点存在，为文件节点或者符号链接至文件的节点 ， 覆盖
		Path tempPath = dst->GetNodePath();
		ConfirmThenMove(from, tempPath);
	}
}


void MoveCmd::ConfirmThenMove(CellNode * from,Path & to)
{
	bool conflict = false;
	CellNode* dst = m_VirtualDisk->GetNodeByPath(to);
	conflict = (dst != nullptr);

	//首相输出在谁的目录下进行的本次操作
	m_VirtualDisk->LogMsgToConsole(from->GetNodePath().str());
	//目标路径已经被检测，应当为空或者文件。不可能为文件夹
	if (dst && dst->GetNodeType()&FileNodeType::FOLD)
	{
		m_VirtualDisk->LogMsgToConsole("sadfasdfasdfasdfasdfasdfasd");
		//checkProc(LanguageDenyAccess);
		return;
	}
	//移动操作
	CellNode* parent = m_VirtualDisk->GetNodeByPath(to.Parent());


	//目标节点与源节点相同，指向同一节点
	if (dst == from)
	{
		from->RemoveFromPreSubList(false);
		from->SetCellName(to.split().back());
		parent->AddSubNode(from);
		++countFile;
	}
	else if (conflict && needAsk)
	{
		//目标节点存在且需要询问
		while (true)
		{
			string answer = m_VirtualDisk->AskForUserInput(StrProcess::sstr("覆盖 %s 吗? (Yes/No/All):", to.str().c_str()));
			transform(answer.begin(), answer.end(), answer.begin(), tolower);
			if (answer == "y" || answer == "yes")
			{
				//移动
				if (dst && dst != from) {
					dst->RemoveFromPreSubList(true);
				}
				from->RemoveFromPreSubList(false);
				from->SetCellName(to.split().back());
				parent->AddSubNode(from);
				++countFile;
				break;
			}
			else if (answer == "n" || answer == "no")
			{
				break;
			}
			else if (answer == "all")
			{
				needAsk = false;
				//移动文件
				if (dst && dst != from) {
					dst->RemoveFromPreSubList(true);
				}
				from->RemoveFromPreSubList(false);
				from->SetCellName(to.split().back());
				parent->AddSubNode(from);
				++countFile;
				break;
			}
		}
	}
	else
	{
		//目标节点不存在或者用户已经输入all选项
		if (dst && dst != from) {
			dst->RemoveFromPreSubList(true);
		}
		from->RemoveFromPreSubList(false);
		from->SetCellName(to.split().back());
		parent->AddSubNode(from);
		++countFile;
	}
}




//############################# 重写，这种方法只能移动到特定的存在目录 ，不能实现修改名称等功能

//bool MoveCmd::Execute(VirtualDiskInside * virtualdisk)
//{
//	m_VirtualDisk = virtualdisk;
//	
//	vector<string> pathItems = cmdParaCollection.m_pathItems;
//
//	//copy和move命令支持单个路径，默认第二条路径为当前工作路径
//	if (pathItems.size() == 1)
//	{
//		pathItems.push_back(".");
//	}
//	
//
//	Path from(pathItems[0]);
//	Path to(pathItems[1]);
//
//	if (from.IsReal() || to.IsReal())
//	{
//		m_VirtualDisk->LogMsgToConsole("不支持真实路径");
//		return false;
//	}
//	if (!Tools::IsLegalPathName(to.split().back()))
//	{
//		m_VirtualDisk->LogMsgToConsole("目录名不正确");
//		return false;
//	}
//
//
//	list<CellNode*> srcNodeList;
//	if (Tools::isWildcard(from.split().back()))
//	{
//		//含有通配符
//		CellNode* prelink = m_VirtualDisk->GetNodeByPath(from.Parent());
//		srcNodeList = prelink->FilterSubNode(from.split().back());
//
//	}
//	else
//	{
//		CellNode* node = m_VirtualDisk->GetNodeByPath(from);
//		if (!node)
//		{
//			m_VirtualDisk->LogMsgToConsole("文件不存在");
//			return false;
//		}
//		if (m_VirtualDisk->IfNodeBeUsing(node))
//		{
//			m_VirtualDisk->LogMsgToConsole("拒绝访问，父级目录正在被使用");
//			return false;
//		}
//		srcNodeList.push_back(node);
//	}
//
//
//	if (srcNodeList.empty())
//	{
//		
//		//没有需要操作的文件
//		return false;
//	}
//	if (!m_VirtualDisk->GetNodeByPath(to) || m_VirtualDisk->GetNodeByPath(to)->GetNodeType()&FileNodeType::FILE_CUSTOM)
//	{
//		m_VirtualDisk->LogMsgToConsole("目标节点不能是文件节点 或者不存在");
//		return false;
//	}
//
//	//在目标文件夹下存在冲突文件
//	string filename = from.FileName();
//	if (!m_VirtualDisk->GetNodeByPath(to)->FilterSubNode(filename).empty())
//	{
//		conflict = true;
//	}
//
//	needAsk = !(cmdParaCollection.m_parsedOptions.find("/y") != cmdParaCollection.m_parsedOptions.end());
//
//
//	for (auto itera = srcNodeList.begin(); itera != srcNodeList.end(); itera++)
//	{
//		MoveNode(*itera, to);
//	}
//
//	m_VirtualDisk->LogMsgToConsole(StrProcess::sstr("移动了%9d 个文件", srcNodeList.size()));
//
//	return false;
//}
//
//
//void MoveCmd::MoveNode(CellNode* from, Path& to)
//{
//	CellNode* dstNode = m_VirtualDisk->GetNodeByPath(to);
//
//	//目标是文件夹或者符号链接
//	if (dstNode->GetNodeType()&FileNodeType::FOLD)
//	{
//		
//		CellNode* node = m_VirtualDisk->LookingForTaget(dstNode);
//		if (!node)
//		{
//			m_VirtualDisk->LogMsgToConsole("找不到路径");
//			//找不到路径
//			return;
//		}
//		else if (from == node)
//		{
//			//相同，不执行
//			return;
//		}
//		CellNode* cur = node->GetParent();
//		while (cur)
//		{
//			if (cur == from)
//			{
//				m_VirtualDisk->LogMsgToConsole("拒绝访问，父级目录正在被使用");
//				return;
//			}
//			cur = cur->GetParent();
//		}
//		//移动该节点
//		if (conflict && needAsk)
//		{
//			while (true)
//			{
//				//询问是否移动
//				string answer = m_VirtualDisk->AskForUserInput(StrProcess::sstr("覆盖 %s 吗? (Yes/No/All):", to.str().c_str()));
//				string result;
//
//				transform(answer.begin(), answer.end(), answer.begin(), tolower);
//				if (answer == "y" || answer == "yes")
//				{
//					//移动
//					from->RemoveFromPreSubList(false);
//					dstNode->AddSubNode(from);
//					break;
//				}
//				else if (answer == "n" || answer == "no")
//				{
//					return;
//				}
//				else if (answer == "all")
//				{
//					needAsk = false;
//					//移动文件
//					from->RemoveFromPreSubList(false);
//					dstNode->AddSubNode(from);
//					break;
//				}
//			}
//		}
//		else
//		{
//			//移动文件
//			from->RemoveFromPreSubList(false);
//			dstNode->AddSubNode(from);
//		}
//	}
//}


//void MoveCmd::MoveImpl(CellNode* from, const Path& to)
//{
//	//首相输出在谁的目录下进行的本次操作
//	m_VirtualDisk->LogMsgToConsole(from->GetNodePath().str());
//
//	CellNode* dst = m_VirtualDisk->GetNodeByPath(to);
//	//目标路径已经被检测，应当为空或者文件。不可能为文件夹
//	if (dst && dst->GetNodeType()&FileNodeType::FOLD)
//	{
//		m_VirtualDisk->LogMsgToConsole("sadfasdfasdfasdfasdfasdfasd");
//		//checkProc(LanguageDenyAccess);
//		return;
//	}
//	//移动操作
//	CellNode* parent = m_VirtualDisk->GetNodeByPath(to.Parent());
//	if (dst && dst != from) {
//		dst->RemoveFromPreSubList(true);
//	}
//	from->RemoveFromPreSubList(false);
//	from->SetCellName(to.split().back());
//	parent->AddSubNode(from);
//	++countFile;
//}
#include "MyString.h"
#include <algorithm>
using namespace std;



vector<string> StrProcess::split(string & str, char separa)
{
	vector<string> ret;

	//初始化第一个元素的位置
	string::size_type separa_pre = 0;
	string::size_type separa_cur = str.find(separa);

	//循环搜索至最后一个元素
	while (separa_cur != string::npos)
	{
		ret.push_back(str.substr(separa_pre, separa_cur - separa_pre));

		separa_pre = separa_cur + 1;
		separa_cur = str.find(separa, separa_pre);
	}

	//将最后一个元素放入vector中
	if (separa_pre < str.size())
	{
		ret.push_back(str.substr(separa_pre));
	}

	return ret;
}

vector<string> StrProcess::SplitNoEmpty(string & str, char separa)
{
	auto ret = split(str, separa);

	auto target = remove_if(ret.begin(), ret.end(), [&](string item) {return item.empty(); });

	ret.erase(target, ret.end());
	return ret;
}

void StrProcess::replace(string & str, string from, string to)
{
	do
	{
		auto i = str.find(from);
		if (i == string::npos)
			break;
		str.replace(i, from.size(), to);
	} while (true);
}

string StrProcess::join(vector<string>& vec, string addStr)
{
	if (vec.empty())
	{
		return "";
	}
	else if (vec.size() == 1)
	{
		return vec.front();
	}
	string ret;
	for (size_t i = 0; i < vec.size(); i++)
	{
		ret += vec[i];
		ret += addStr;
	}
	//ret += vec.back();
	return ret;
}

string StrProcess::stripspace(string & str)
{
	locale loc;
	string ret = str;
	while (ret.size() > 0 && isspace(ret.front()))
	{
		ret.erase(ret.begin());
	}
	while (ret.size() > 0 && isspace(ret.back()))
	{
		ret.pop_back();
	}
	return ret;
}
#include "Path.h"
#include "MyString.h"
#include "Common.h"
Path::Path()
{
}
Path::Path(const string & Unprocessed)
{
	startNode = 0;
	append(Unprocessed);
}

Path & Path::append(string pathStr)
{
	//首先，将pathStr中的所有\替换为/，然后在按照/来分离

	//取地址替换
	StrProcess::replace(pathStr, "\\", "/");


	//设置路径类型  ， （绝对）根路径，真实路径，（相对）当前路径
	if (startNode == 0)
	{
		startNode = pathStr.front();
		startNode = (startNode == '/' || startNode == '@') ? startNode : '.';
	}
	vector<string> items = StrProcess::SplitNoEmpty(pathStr, '/');

	for (size_t i = 0; i < items.size(); i++)
	{
		if (i == 0)
		{
			//如果用户输入为C盘开始的地址
			if (items[0] == "c:"||items[0] =="C:")
			{
				startNode = '/';
				continue;
			}
		}
		if (items[i] == ".")
		{

		}
		else if (items[i] == ".." && !pathItems.empty() && pathItems.back() != "..")
		{
			//如果是上一级目录的话，就将路径中的最后一项弹出，寻路时不在向下级寻找
			//如果被弹出的路径是符号链接，则可能出错
			pathItems.pop_back();
		}
		else
		{
			pathItems.push_back(items[i]);
		}
	}

	if (IsReal() && !pathItems.empty() && pathItems.front().front() == '@')
	{
		//如果是真实路径，则将路径名中的第一个节点的名字跳过“@”符号
		pathItems.front().assign(pathItems.front().begin() + 1, pathItems.front().end());
	}

	return *this;
}
Path Path::Self() const
{
	return Path(*this);
}
bool Path::IsAbsolute() const
{
	return startNode == '/';
}

bool Path::IsReal() const
{
	return startNode == '@';
}



Path Path::Parent() const
{
	//返回上级
	return this->Self().append("..");
}

//待实现
string Path::str()
{

	if (IsReal())
	{
		return StrProcess::join(pathItems, "\\");
	}
	else if (IsAbsolute())
	{
		return "C:/" + StrProcess::join(pathItems, "/");
	}
	else
	{
		return "./" + StrProcess::join(pathItems, "/");
	}
}

vector<string> Path::split() const
{
	return pathItems.empty() ? vector<string>{"."} : pathItems;
}

string Path::Title()
{
	string filename = FileName();
	size_t lastdot = filename.find_last_of('.');
	if (lastdot == string::npos)
	{
		return filename;
	}
	else
	{
		return filename.substr(0, lastdot);
	}
}

string Path::FileName() const
{
	if (pathItems.empty())
	{
		return "";
	}
	if (!Tools::IsLegalFileName(pathItems.back()))
	{
		return "";
	}
	return pathItems.back();
}

string Path::StartNode() const
{
	if (IsReal())
	{
		return "@";
	}
	else if (IsAbsolute())
	{
		return "/";
	}
	else
	{
		return ".";
	}
}
/ /   p c h . c p p :   Nh4Y[^vneNbR@b_ v 
  
 # i n c l u d e   " p c h . h "  
  
 / /    N,`QN_eudkeNFOYg`OO(uv/fh4YOYu[0 
 #include "RdCmd.h"
#include "VirtualDiskInside.h"

bool RdCmd::Execute(VirtualDiskInside * virtualdisk)
{
	m_VirtualDisk = virtualdisk;
	vector<string> pathItems = cmdParaCollection.m_pathItems;
	if (pathItems.empty())
	{
		return false;
		//路径是空的
		//命令语法不正确，最少一条路径，path中已经经过判断
	}
	//对每条路径分别处理
	for (size_t i = 0; i < pathItems.size(); i++)
	{
		CellNode* node = NULL;
		string wildcard;

		//首先过滤不存在的项目
		CellNode* tempNode = m_VirtualDisk->GetNodeByPath(pathItems[i]);
		if (!tempNode)
		{
			//没有相应的文件
			continue;
		}
		else if (m_VirtualDisk->IfNodeBeUsing(tempNode))
		{
			//文件正在使用
			m_VirtualDisk->LogMsgToConsole("目标文件包含工作路径");
			continue;
		}
		else
		{
			node = tempNode;
		}

		//开始处理
		if (wildcard.empty())
		{
			wildcard = "*";
		}

		if (node->GetNodeType()&FILE_CUSTOM && node->GetNodeType()&LINK)
		{
			//目标文件不是文件夹
			m_VirtualDisk->LogMsgToConsole("目标文件不是文件夹");
		}
		else if (node->GetNodeType()&FOLD && node->GetNodeType()&LINK)
		{
			//从父级节点中删除
			m_VirtualDisk->LogMsgToConsole("此处不检查链接目标文件夹是否为空，直接删除");
			node->RemoveFromPreSubList(true);
		}
		else if (node->GetNodeType()&FILE_CUSTOM)
		{
			m_VirtualDisk->LogMsgToConsole("目标文件不是文件夹");
			//目标文件不是文件夹
		}
		else if (node->GetNodeType()&FOLD)
		{
			//如果指定的目录非空，且用户没有输入递归删除的指定，则不执行该路径
			if (!(cmdParaCollection.m_parsedOptions.find("/s") != cmdParaCollection.m_parsedOptions.end()) && !node->FilterSubNode("*").empty())
			{
				//目录不是空的
				m_VirtualDisk->LogMsgToConsole("目录不是空的");
				continue;
			}
			node->RemoveFromPreSubList(true);
		}
		else
		{
			m_VirtualDisk->LogMsgToConsole("如果此条信息被打印，说明程序存在意外情况，详细判断请见：bool RdCmd::Execute");
		}
	}
	return true;
}#include "RenCmd.h"
#include "VirtualDiskInside.h"
bool RenCmd::Execute(VirtualDiskInside * virtualdisk)
{
	m_VirtualDisk = virtualdisk;
	//类似于Mklink的路径存取方法

	//第一个路径存放着待修改节点的路径信息
	//第二个路径存放着要修改成的名字

	//查找检测第一个路径所指向节点的状态
		//不存在 -》 给出提示并退出
		//存在 -》 是否正在被使用
					//是	-》 退出
					//否	-》 目标名是否合法
							//合法 -》修改节点名

	vector<string> pathItems = cmdParaCollection.m_pathItems;
	Path srcNodePath(pathItems[0]);
	string applyName = pathItems[1];

	CellNode* srcNode = m_VirtualDisk->GetNodeByPath(srcNodePath);

	if (!srcNode)
	{
		m_VirtualDisk->LogMsgToConsole("目标节点不存在");
		return false;
	}
	else if (m_VirtualDisk->IfNodeBeUsing(srcNode))
	{
		m_VirtualDisk->LogMsgToConsole("目标路径是工作路径");
		return false;
	}
	else if (!Tools::IsLegalFileName(applyName))
	{
		m_VirtualDisk->LogMsgToConsole("名称不合法");
		return false;
	}
	else if (srcNode->GetParent()->GetNode(applyName))
	{
		m_VirtualDisk->LogMsgToConsole("存在同名文件");
		return false;
	}
	else
	{
		srcNode->SetCellName(applyName);
	}
	return true;
}
#include "SaveCmd.h"
#include "Path.h"
#include "VirtualDiskInside.h"
#include<fstream>

bool SaveCmd::Execute(VirtualDiskInside * virtualdisk)
{
	m_VirtualDisk = virtualdisk;

	//该命令直接收一条路径，必须为真实路径

	vector<string> pathItems = cmdParaCollection.m_pathItems;

	Path dstPath(pathItems[0]);

	if (!dstPath.IsReal())
	{
		m_VirtualDisk->LogMsgToConsole("不是真实路径");
		return false;
	}
	//以二进制格式打开文件
	fstream fout;
	fout.open(dstPath.str(), ios::binary | ios::out);

	if (!fout)
	{
		m_VirtualDisk->LogMsgToConsole("文件打开失败");
		return false;
	}

	CellNode* rootNode = m_VirtualDisk->GetRootNode();

	//使用节点的重载<<运算符对节点进行输出
	fout << *rootNode;

	fout.close();

	return true;
}
#include "TouchCmd.h"
#include "VirtualDiskInside.h"
bool TouchCmd::Execute(VirtualDiskInside * virtualdisk)
{
	vector<string> pathItems = cmdParaCollection.m_pathItems;

	for (size_t i = 0; i < pathItems.size(); i++)
	{
		Path path = pathItems[i];
		//查看当前文件是否已经存在

		//创建文件的命令 不检查符号链接，仅判断文件名是否相同
		//如果存在，给出提示，
		//如果不存在，创建该文件

		CellNode* node;
		node = virtualdisk->GetNodeByPath(path);
		if (node)
		{
			virtualdisk->LogMsgToConsole("存在同名文件");
		}
		else
		{
			CellNode* prelink = virtualdisk->GetNodeByPath(path.Parent());

			//创建节点，修改时间在构造函数中实现
			//设置父节点在添加函数中实现

			//virtualdisk->LogMsgToConsole("该位置可能出错，当文件名为空时也会创建：bool TouchCmd::Execute(VirtualDisk * virtualdisk) ");
			if (path.FileName().empty())
			{
				virtualdisk->LogMsgToConsole("该位置可能出错，当文件名为空时也会创建,所以添加此判断 ：bool TouchCmd::Execute(VirtualDisk * virtualdisk) ");
				return false;
			}

			CellNode* fileNode = new CellNode();
			//该位置可能出错
			fileNode->SetCellName(path.FileName());
			fileNode->SetNodeType(FileNodeType::FILE_CUSTOM);
			prelink->AddSubNode(fileNode);

			//设置文件内容；**********************************可能不方便测试
			//默认为空
		}
	}
	return true;
}
/ /   V D . c p p   :   dkeNS+T  " m a i n "   Qpe0z^gbL\(WdkY _Yv^~_g0 
 / /  
  
 # i n c l u d e   " p c h . h "  
 # i n c l u d e   < i o s t r e a m >  
 # i n c l u d e   " V i r t u a l D i s k S y s t e m . h "  
  
 i n t   m a i n ( )  
 {  
 	 V i r t u a l D i s k S y s t e m *   v i r t u a l D i s k S y s t e m   =   n e w   V i r t u a l D i s k S y s t e m ( ) ;  
  
 	 s t d : : c o u t   < <   " H e l l o   V i r t u a l D i s k   i s   i n i t i a l i z i n g ! \ n " ;  
 	 f o r   ( i n t   i   =   0 ;   i   <   3 0 ;   i + + )  
 	 {  
 	 	 s t d : : c o u t   < <   " * " ;  
 	 }  
 	 s t d : : c o u t   < <   " \ n " ;  
 	 i f   ( ! v i r t u a l D i s k S y s t e m - > I n i t S y s t e m ( ) )  
 	 {  
 	 	 s t d : : c o u t   < <   " p r o g r a m   i n i t i a l i z a t i o n   f a i l u r e ! \ n " ;  
 	 }  
 }  
  
 / /   Lz^:   C t r l   +   F 5   b  >   _YgbL( N)  US 
 / /   z^:   F 5   b  >   _Y US 
  
 / /   eQc:y:    
 / /       1 .   O(uQeHhDn{thVzSmR/ {teN 
 / /       2 .   O(uVDn{thVzSc0RnNx{t 
 / /       3 .   O(uQzSgwubQTvQNmo` 
 / /       4 .   O(uRhzSgw 
 / /       5 .   l0R yv >  mRey NR^evNxeNbl0R yv >  mRs	gy N\s	gNxeNmR0Ryv 
 / /       6 .   \egQ!kSb _dkyvl0R eN >  Sb _ >  yv v^	b  . s l n   eN 
 #include "VirtualDiskInside.h"
#include <iostream>
VirtualDiskInside::VirtualDiskInside()
{
	
}

VirtualDiskInside::~VirtualDiskInside()
{
	delete rootNode;
}

bool VirtualDiskInside::InitFileSystem()
{
	rootNode = new CellNode();
	rootNode->SetCellName("/");
	rootNode->SetNodeType(FOLD);
	workingNode = rootNode;
	return true;
}

void VirtualDiskInside::Execute(Command * cmd)
{
	cmd->Execute(this);
}

CellNode * VirtualDiskInside::GetNodeByPath(const Path & path)
{
	if (path.IsAbsolute())
	{
		return rootNode->GetNode(path);
	}
	else
	{
		return workingNode->GetNode(path);
	}
}



CellNode * VirtualDiskInside::LookingTarget(CellNode * node)
{
	if (!node)
	{
		return NULL;
	}
	if(node->GetNodeType() & LINK)
	{
		vector<char> temp = node->Content();
		string tempStrPath = string(temp.begin(), temp.end());
		Path targetPath(tempStrPath);
		CellNode* target = GetNodeByPath(targetPath);
		if (!target)
		{
			return NULL;
		}
		else if ((target->GetNodeType() & FILE_CUSTOM) && (!(node->GetNodeType() & FILE_CUSTOM)))
		{
			return NULL;
		}
		else if ((target->GetNodeType() & FOLD) && (!(node->GetNodeType() & FOLD)))
		{
			return NULL;
		}
		else
		{
			return target;
		}
	}
	else
	{
		return node;
	}
}

//该位置寻路可能出错,判断方式不知是否正确，
CellNode * VirtualDiskInside::LookingForTaget(CellNode * node)
{
	CellNode* target = LookingTarget(node);
	while (target && (target->GetNodeType() & LINK))
	{
		target = LookingTarget(target);
	}
	return target;
}



void VirtualDiskInside::LogMsgToConsole(string msg)
{
	cout << msg << endl;
}

string VirtualDiskInside::AskForUserInput(const string & output)
{
	cout << output << ":";
	string answer;
	cin >> answer;
	return answer;
}



CellNode * VirtualDiskInside::GetRootNode()
{
	return rootNode;
}
void VirtualDiskInside::SetRootNode(CellNode* rootNodeSet)
{
	rootNode = rootNodeSet;
}

CellNode * VirtualDiskInside::GetWorkingNode()
{
	return workingNode;
}

void VirtualDiskInside::SetWorkingNode(CellNode * node)
{
	workingNode = node;
}


Path VirtualDiskInside::GetWorkingPath()
{
	CellNode* cur = workingNode;
	while (cur)
	{
		workingPath.push_front(cur);
		cur = cur->GetParent();
	}
	Path ret;
	for (auto it = workingPath.begin(); it != workingPath.end(); it++)
	{
		ret.append((*it)->GetCellName());
	}
	return ret;
}


string VirtualDiskInside::GetWorkingPathString()
{
	workingPath.clear();
	CellNode* cur = workingNode;
	while (cur)
	{
		workingPath.push_front(cur);
		cur = cur->GetParent();
	}
	Path ret;
	for (auto it = workingPath.begin(); it != workingPath.end(); it++)
	{
		ret.append((*it)->GetCellName());
	}
	return ret.str();
}

bool VirtualDiskInside::IfNodeBeUsing(CellNode * node)
{
	CellNode* cur = workingNode;
	while (cur)
	{
		if (cur == node)
		{
			return true;
		}
		cur = cur->GetParent();
	}
	return false;
}
#include "VirtualDiskSystem.h"
#include <iostream>
VirtualDiskSystem::VirtualDiskSystem()
{
	virtualDiskInside = new VirtualDiskInside();
}


bool VirtualDiskSystem::InitSystem()
{
	//执行文件系统的初始化工作
	if (!virtualDiskInside->InitFileSystem())
	{
		return false;
	}

	//初始化系统的命令
	string initCmd = "md /\"bin\"";
	virtualDiskInside->Execute(commandFactory.CreatCommand(initCmd));

	initCmd = "md /\"b in\"/st";
	virtualDiskInside->Execute(commandFactory.CreatCommand(initCmd));

	initCmd = "touch /\"b in\"/1.txt";
	virtualDiskInside->Execute(commandFactory.CreatCommand(initCmd));
	initCmd = "touch /\"b in\"/11.txt";
	virtualDiskInside->Execute(commandFactory.CreatCommand(initCmd));
	initCmd = "touch /\"b in\"/2.txt";
	virtualDiskInside->Execute(commandFactory.CreatCommand(initCmd));



	initCmd = "mklink /d sym /\"bin\"";
	virtualDiskInside->Execute(commandFactory.CreatCommand(initCmd));
	initCmd = "mklink /d sym1 sym";
	virtualDiskInside->Execute(commandFactory.CreatCommand(initCmd));


	initCmd = "md baa";
	virtualDiskInside->Execute(commandFactory.CreatCommand(initCmd));

	initCmd = "touch /baa/1.txt";
	virtualDiskInside->Execute(commandFactory.CreatCommand(initCmd));
	initCmd = "touch /baa/11.txt";
	virtualDiskInside->Execute(commandFactory.CreatCommand(initCmd));
	initCmd = "touch /baa/2.txt";
	virtualDiskInside->Execute(commandFactory.CreatCommand(initCmd));

	initCmd = "touch /1.txt";
	virtualDiskInside->Execute(commandFactory.CreatCommand(initCmd));
	initCmd = "touch /11.txt";
	virtualDiskInside->Execute(commandFactory.CreatCommand(initCmd));
	initCmd = "touch /2.txt";
	virtualDiskInside->Execute(commandFactory.CreatCommand(initCmd));


	initCmd = "mklink  s.txt /1.txt";
	virtualDiskInside->Execute(commandFactory.CreatCommand(initCmd));
	initCmd = "mklink y.txt s.txt";
	virtualDiskInside->Execute(commandFactory.CreatCommand(initCmd));
	//std::cout << "Program initialization completed!\n";
	RunSystem();
	return true;

}

void VirtualDiskSystem::RunSystem()
{
	bool flag = true;

	

	std::cout << "Program initialization completed!\n";
	while (1)
	{

		if (flag)
		{
			//string workingPathString = virtualDisk.GetWorkingPathString();

			std::cout << virtualDiskInside->GetWorkingPathString() << "> ";
			flag = false;
		}

		//读取用户命令 ，临时保存进
		char cmd[MAX_CMD_CHAR];
		std::cin.getline(cmd, MAX_CMD_CHAR);

		if (cmd == "exit")
			break;

		//判断是否是退出系统的指令
			//如果是退出系统，则break跳出当前循环接收

		//不是退出系统，开始构建命令并执行
		if (cmd[0] != '\0')
		{
			//临时保存用户的输入
			//userInput.wholeCmd = cmd;

			//使用命令工厂创建任务
			command = commandFactory.CreatCommand(cmd);
			if (command != NULL)
			{
				//命令创建成功，开始执行
				virtualDiskInside->Execute(command);
			}
			else
			{
				cout << "\n命令创建失败，请重新输入（多次失败请检查系统）：" << endl;
			}


			for (int i = 0; i < MAX_CMD_CHAR; i++)
			{
				cmd[i] = '\0';
			}
			flag = true;
		}

	}
	return;

}
